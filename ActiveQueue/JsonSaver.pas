unit JsonSaver;

interface

uses
  JsonableInterface, System.Generics.Collections;

type
  /// A class that saves given state in a file.
  TJsonSaver = class(TObject)
  strict private
  const
    Suffix = '-YYYY-mm-dd-hh-nn-ss';

  var
    FLockObject: TObject;
    /// a parent folder of the file in which the state should be written
    FFileFolder: String;
    /// a suggested name of the file in which the state should be saved. If not available (i.e. such
    /// a file already exists), a new one will be generated
    FFileName: String;
    /// Extension of the file in which the state should be saved.
    FFileExtension: String;

    /// <summary>Find an available name for a file in the folder which the path referes to.
    /// If no file under given path exists, that path is returned. If there exists a file,
    /// then a new name is generated by prepending a timestamp to the given name.
    /// </summary>
    /// <param name="Path">Suggested path. If there exists a file, a new path is to generated. </param>
    /// <param name="Format">format of the current timestamp to be prepended to the file name </param>
    function GetAvailablePath(const Path: String; const Format: String): String;

    /// Return a name (without extension and path to the parent folder) under which a file can be saved in
    /// FFileFolder.
    function getAvailableName(): String;
  public
    procedure Save(const FilePath: String; const Obj: Jsonable); overload;
    procedure Save(const Obj: Jsonable); overload;
    procedure SaveMulti(const FilePath: String; const Items: TList<Jsonable>);
    constructor Create(); overload;
    constructor Create(const FilePath: String); overload;
    destructor Destroy(); override;

  end;

implementation

uses
  System.IOUtils, System.SysUtils, System.JSON;

{ TStateSaver }

constructor TJsonSaver.Create;
begin
  FLockObject := Tobject.Create();
end;

constructor TJsonSaver.Create(const FilePath: String);
var
  NameExt: String;
begin
  Create();
  FFileFolder := ExtractFilePath(FilePath);
  FFileExtension := ExtractFileExt(FilePath);
  NameExt := ExtractFileName(FilePath);
  FFileName := Copy(NameExt, 1, Length(NameExt) - Length(FFileExtension));
end;

destructor TJsonSaver.Destroy;
begin
  FLockObject.DisposeOf;
  inherited;
end;

function TJsonSaver.getAvailableName: String;
var
  FullPath: String;
  Counter: Integer;
  NewName, BaseName: String;
begin
  FullPath := FFileFolder + FFileName + FFileExtension;
  if not(TFile.Exists(FullPath)) then
    Result := FFileName
  else
  begin
    BaseName := FFileName + formatdatetime(Suffix, Now());
    NewName := BaseName;
    FullPath := FFileFolder + BaseName + FFileExtension;
    Counter := 1;
    while (TFile.Exists(FullPath)) do
    begin
      NewName := Format('%s-%d', [BaseName, Counter]);
      FullPath := FFileFolder + NewName + FFileExtension;;
      Counter := Counter + 1;
      Writeln('Loop: new name = ' + NewName);
    end;
    Result := NewName;

  end;
  Writeln('Available name for config file: ' + Result);
end;

function TJsonSaver.GetAvailablePath(const Path, Format: String): String;
var
  TryName: String;
  folder, nameExt, name, ext: String;
begin
  TryName := path;
  while TFile.Exists(TryName) do
  begin
    Folder := ExtractFilePath(TryName);
    Ext := ExtractFileExt(TryName);
    NameExt := ExtractFileName(TryName);
    Name := Copy(NameExt, 1, Length(NameExt) - Length(Ext));
    TryName := Folder + Name + formatdatetime(Format, Now()) + Ext;
  end;
  Result := TryName;
end;

procedure TJsonSaver.Save(const FilePath: String; const Obj: Jsonable);
var
  OutFileName: String;
  jo: TJsonObject;
  Text: String;
begin
  TMonitor.Enter(FLockObject);
  Try
    OutFileName := GetAvailablePath(FilePath, Suffix);
    jo := Obj.ToJson();
    if jo <> nil then
    begin
      Text := jo.ToString();
      TFile.AppendAllText(OutFileName, Text);
      Text := '';
      jo.DisposeOf;
    end;
  Finally
    TMonitor.Exit(FLockObject);
  End;

end;

procedure TJsonSaver.Save(const Obj: Jsonable);
var
  OutFileName: String;
  jo: TJsonObject;
  Text, FullPath: String;
begin
  TMonitor.Enter(FLockObject);
  Try
    OutFileName := GetAvailableName();
    FullPath := FFileFolder + OutFileName + FFileExtension;
    jo := Obj.ToJson();
    if jo <> nil then
    begin
      Text := jo.ToString();
      TFile.AppendAllText(FullPath, Text);
      Text := '';
      jo.DisposeOf;
    end;
  Finally
    TMonitor.Exit(FLockObject);
  End;
end;

procedure TJsonSaver.SaveMulti(const FilePath: String; const Items: TList<Jsonable>);
var
  OutFileName: String;
  builder: TStringBuilder;
  I, L: Integer;
  Content: TJsonObject;
begin
  TMonitor.Enter(FLockObject);
  Try
    Builder := TStringBuilder.Create();
    OutFileName := GetAvailablePath(FilePath, Suffix);
    Builder.Append('[');
    L := Items.Count;
    for I := 0 to L - 2 do
    begin
      Content := Items[I].toJson;
      Builder.Append(Content.ToString);
      Content.DisposeOf;
      Builder.Append(',');
    end;
    Content := Items[L - 1].toJson;
    Builder.Append(Content.ToString);
    Content.DisposeOf;
    Builder.Append(']');
    TFile.AppendAllText(OutFileName, Builder.ToString());
  Finally
    Builder.DisposeOf;
    TMonitor.Exit(FLockObject);
  End;
end;

end.
