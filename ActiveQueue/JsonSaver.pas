unit JsonSaver;

interface

uses
  JsonableInterface, System.Generics.Collections;

type
  /// A class that saves given state in a file.
  TJsonSaver = class(TObject)
  strict private
  const
    Suffix = '-YYYY-mm-dd_hh_nn_ss';

  var
    FLockObject: TObject;

    /// <summary>Find an available name for a file in the folder which the path referes to.
    /// If no file under given path exists, that path is returned. If there exists a file,
    /// then a new name is generated by prepending a timestamp to the given name.
    /// </summary>
    /// <param name="Path">Suggested path. If there exists a file, a new path is to generated. </param>
    /// <param name="Format">format of the current timestamp to be prepended to the fila name </param>
    function GetAvailablePath(const Path: String; const Format: String): String;
  public
    procedure Save(const FilePath: String; const Obj: Jsonable);
    procedure SaveMulti(const FilePath: String; const Items: TList<Jsonable>);
    constructor Create();
    destructor Destory(); override;

  end;

implementation

uses
  System.IOUtils, System.SysUtils, System.JSON;

{ TStateSaver }

constructor TJsonSaver.Create;
begin
  FLockObject := Tobject.Create();
end;

destructor TJsonSaver.Destory;
begin
  FLockObject.DisposeOf;
  inherited;
end;

function TJsonSaver.GetAvailablePath(const Path, Format: String): String;
var
  TryName: String;
  folder, nameExt, name, ext: String;
begin
  TryName := path;
  while TFile.Exists(TryName) do
  begin
    Folder := ExtractFilePath(TryName);
    Ext := ExtractFileExt(TryName);
    NameExt := ExtractFileName(TryName);
    Name := Copy(NameExt, 1, Length(NameExt) - Length(Ext));
    TryName := Folder + Name + formatdatetime(Format, Now()) + Ext;
  end;
  Result := TryName;
end;

procedure TJsonSaver.Save(const FilePath: String; const Obj: Jsonable);
var
  OutFileName: String;
  jo: TJsonObject;
  Text: String;
begin
  TMonitor.Enter(FLockObject);
  Try
    OutFileName := GetAvailablePath(FilePath, Suffix);
    jo := Obj.ToJson();
    if jo <> nil then
    begin
      Text := jo.ToString();
      TFile.AppendAllText(OutFileName, Text);
      Text := '';
      jo.DisposeOf;
    end;
  Finally
    TMonitor.Exit(FLockObject);
  End;

end;

procedure TJsonSaver.SaveMulti(const FilePath: String; const Items: TList<Jsonable>);
var
  OutFileName: String;
  builder: TStringBuilder;
  I, L: Integer;
  Content: String;
begin
  TMonitor.Enter(FLockObject);
  Try
    OutFileName := GetAvailablePath(FilePath, Suffix);
    Builder := TStringBuilder.Create();
    Builder.Append('[');
    L := Items.Count;
    for I := 0 to L - 2 do
    begin
      Builder.Append(Items[I].toJson.ToString);
      Builder.Append(',');
    end;
    Builder.Append(Items[L - 1].toJson.ToString);
    Builder.Append(']');
    Content := Builder.ToString();
    TFile.AppendAllText(OutFileName, Content);
    Builder.DisposeOf;
  Finally
    TMonitor.Exit(FLockObject);
  End;
end;

end.
